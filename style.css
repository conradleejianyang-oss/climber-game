*** Update File: climber-game/index.html
@@
     <!-- The column of holds. Each hold will be dynamically generated in script.js -->
     <div id="rockContainer"></div>
-    <!-- A simple representation of the climber. In this MVP the character is a block. -->
-    <div id="climber"></div>
+    <!-- Parallax background layers. These are stacked behind the game elements and scrolled at different speeds. -->
+    <div id="parallaxContainer">
+      <div id="layer1" class="parallax-layer"></div>
+      <div id="layer2" class="parallax-layer"></div>
+      <div id="layer3" class="parallax-layer"></div>
+      <div id="layer4" class="parallax-layer"></div>
+    </div>
+    <!-- Canvas used to draw the animated climber from the sprite sheet. -->
+    <canvas id="climberCanvas" width="80" height="200"></canvas>
*** End Patch

*** Update File: climber-game/style.css
@@
-/* Simple climber representation. It's placed above the bottom controls. */
-#climber {
-  position: absolute;
-  bottom: 70px;
-  left: 50%;
-  transform: translateX(-50%);
-  width: 32px;
-  height: 40px;
-  background-color: #555;
-  border-radius: 4px;
-}
+/* Parallax container and layers stack behind the game and scroll horizontally. */
+#parallaxContainer {
+  position: absolute;
+  top: 0;
+  left: 0;
+  width: 100%;
+  height: 100%;
+  overflow: hidden;
+  z-index: 0;
+  pointer-events: none;
+}
+.parallax-layer {
+  position: absolute;
+  top: 0;
+  left: 0;
+  width: 100%;
+  height: 100%;
+  background-repeat: repeat-x;
+  background-position: 0 0;
+  background-size: cover;
+  pointer-events: none;
+}
+/* Canvas used to draw the animated climber sprite. It sits above the holds but below the UI. */
+#climberCanvas {
+  position: absolute;
+  bottom: 70px;
+  left: 50%;
+  transform: translateX(-50%);
+  width: 80px;
+  height: 200px;
+  z-index: 2;
+  pointer-events: none;
+}
*** End Patch

*** Update File: climber-game/script.js
@@
   const rightBtn = document.getElementById('rightBtn');
+
+  // References to new parallax layers and climber canvas. These will be used
+  // to render the background and animated climber based off the provided
+  // sprite sheet and manifest. Paths to images are relative to index.html;
+  // the assets live in the repository root. Adjust if you move files.
+  const parallaxLayers = [
+    {
+      el: document.getElementById('layer1'),
+      day: '../layer1_sky_day.png',
+      night: '../layer1_sky_night.png',
+      speed: 0.1
+    },
+    {
+      el: document.getElementById('layer2'),
+      day: '../layer2_mountains_day.png',
+      night: '../layer2_mountains_night.png',
+      speed: 0.2
+    },
+    {
+      el: document.getElementById('layer3'),
+      day: '../layer3_treeline_day.png',
+      night: '../layer3_treeline_night.png',
+      speed: 0.4
+    },
+    {
+      el: document.getElementById('layer4'),
+      day: '../layer4_rock_edge.png',
+      night: '../layer4_rock_edge.png',
+      speed: 0.6
+    }
+  ];
+  const climberCanvas = document.getElementById('climberCanvas');
+  const climberCtx = climberCanvas ? climberCanvas.getContext('2d') : null;
+
+  // Inline manifest describing the mapping of each row-column in the sprite
+  // sheet to its corresponding action and frame index. This object is
+  // autogenerated from manifest.json and embedded here to avoid network
+  // requests at runtime. Each key is in the form "row-col".
+  const manifest = { …same as provided… };
+
+  // Prepare arrays of frame coordinates for each action. Once the sprite
+  // sheet loads, we calculate cell sizes and populate actionsFrames.
+  const actionsFrames = {
+    'idle-hang': [],
+    'reach': [],
+    'pull-up': [],
+    'slip': [],
+    'fall': []
+  };
+  let cellW = 0;
+  let cellH = 0;
+  let spriteLoaded = false;
+  const spriteSheet = new Image();
+  spriteSheet.src = '../climber_sprite_sheet.png';
+  spriteSheet.onload = function() {
+    cellW = spriteSheet.width / 24;
+    cellH = spriteSheet.height / 5;
+    // Populate action frame arrays
+    Object.keys(manifest).forEach(key => {
+      const entry = manifest[key];
+      const parts = key.split('-');
+      const row = parseInt(parts[0], 10);
+      const col = parseInt(parts[1], 10);
+      const frame = { x: col * cellW, y: row * cellH };
+      actionsFrames[entry.action][entry.frame_index] = frame;
+    });
+    spriteLoaded = true;
+  };
+
+  // Animation state variables for the climber.
+  let currentAction = 'idle-hang';
+  let currentFrame = 0;
+  let animLastTime = null;
+  const animFrameDuration = 1000 / 24; // 24 fps
+
+  /** Draw the current frame of the current action onto the climber canvas. */
+  function drawClimberFrame() {
+    if (!spriteLoaded || !climberCtx) return;
+    const frame = actionsFrames[currentAction][currentFrame];
+    if (!frame) return;
+    climberCtx.clearRect(0, 0, climberCanvas.width, climberCanvas.height);
+    climberCtx.drawImage(
+      spriteSheet,
+      frame.x,
+      frame.y,
+      cellW,
+      cellH,
+      0,
+      0,
+      climberCanvas.width,
+      climberCanvas.height
+    );
+  }
+
+  /** Main loop to animate the climber. Advances the frame index at a constant
+   * rate and redraws the sprite. Uses requestAnimationFrame for smooth rendering.
+   */
+  function animateClimber(time) {
+    if (animLastTime === null) animLastTime = time;
+    const delta = time - animLastTime;
+    if (delta >= animFrameDuration) {
+      const framesForAction = actionsFrames[currentAction];
+      if (framesForAction && framesForAction.length > 0) {
+        currentFrame = (currentFrame + 1) % framesForAction.length;
+      }
+      animLastTime = time;
+    }
+    drawClimberFrame();
+    requestAnimationFrame(animateClimber);
+  }
+  // Kick off the climber animation loop.
+  requestAnimationFrame(animateClimber);
+
+  /** Play a sequence of animations in order. Each action runs for one second
+   * (24 frames) before progressing to the next. Once all actions have
+   * completed the optional callback is invoked.
+   */
+  function playActionSequence(actions, onComplete) {
+    let index = 0;
+    function next() {
+      if (index >= actions.length) {
+        if (onComplete) onComplete();
+        return;
+      }
+      currentAction = actions[index];
+      currentFrame = 0;
+      index++;
+      setTimeout(next, 1000);
+    }
+    next();
+  }
+
+  // Parallax scrolling variables. A separate loop updates the horizontal
+  // background positions for each layer based on elapsed time.
+  let parallaxX = 0;
+  let lastParallax = null;
+  function parallaxLoop(timestamp) {
+    if (lastParallax === null) lastParallax = timestamp;
+    const dt = timestamp - lastParallax;
+    lastParallax = timestamp;
+    parallaxX += dt * 0.02;
+    parallaxLayers.forEach(layer => {
+      const pos = -parallaxX * layer.speed;
+      layer.el.style.backgroundPosition = pos + 'px 0';
+    });
+    requestAnimationFrame(parallaxLoop);
+  }
+  requestAnimationFrame(parallaxLoop);
+
+  // Day/night toggling based on system clock or manual key press.
+  let isNight = (new Date().getHours() < 6 || new Date().getHours() >= 18);
+  function updateDayNight() {
+    parallaxLayers.forEach(layer => {
+      layer.el.style.backgroundImage = `url('${isNight ? layer.night : layer.day}')`;
+    });
+  }
+  updateDayNight();
@@
   function handleMove(side) {
     if (!gameRunning) return;
     // Determine whether the player's choice matches the bottom hold.
     const currentHold = holds[0];
     if (side === currentHold) {
@@ function handleMove(side) {
-      // Correct choice: increment score, remove bottom hold and add a new one on top.
-      score += 1;
-      holds.shift();
-      holds.push(Math.random() < 0.5 ? 'left' : 'right');
-      scoreLabel.textContent = 'Score: ' + score;
-      // Reset the timer for the next move.
-      timeBarWidth = 100;
-      // Re-render holds to reflect the updated list.
-      renderHolds();
-    } else {
-      // Incorrect choice ends the game.
-      endGame();
-    }
+      // Correct choice: increment score, update holds and reset timer.
+      score += 1;
+      holds.shift();
+      holds.push(Math.random() < 0.5 ? 'left' : 'right');
+      scoreLabel.textContent = 'Score: ' + score;
+      timeBarWidth = 100;
+      renderHolds();
+      // Play the reach and pull-up animations sequentially, then return to idle.
+      playActionSequence(['reach', 'pull-up'], () => {
+        currentAction = 'idle-hang';
+      });
+    } else {
+      // Incorrect choice: play fall animation and end the game afterwards.
+      playActionSequence(['fall'], () => {
+        endGame();
+      });
+    }
   }
*** End Patch

*** Update File: climber-game/script.js
@@
   // Event listeners for UI and keyboard.
   startBtn.addEventListener('click', startGame);
   restartBtn.addEventListener('click', startGame);
   leftBtn.addEventListener('click', () => handleMove('left'));
   rightBtn.addEventListener('click', () => handleMove('right'));
 
   // Listen for keyboard input so players can use the arrow keys instead of buttons.
-  document.addEventListener('keydown', (event) => {
-    if (!gameRunning) return;
-    if (event.key === 'ArrowLeft') {
-      handleMove('left');
-    } else if (event.key === 'ArrowRight') {
-      handleMove('right');
-    }
-  });
+  document.addEventListener('keydown', (event) => {
+    // Pressing "T" toggles day/night mode regardless of game state.
+    if (event.key && event.key.toLowerCase() === 't') {
+      isNight = !isNight;
+      updateDayNight();
+      return;
+    }
+    // Only handle movement keys when the game is running.
+    if (!gameRunning) return;
+    if (event.key === 'ArrowLeft') {
+      handleMove('left');
+    } else if (event.key === 'ArrowRight') {
+      handleMove('right');
+    }
+  });
/* Simple climber representation. It's placed above the bottom controls. */
-#climber {
-  position: absolute;
-  bottom: 70px;
-  left: 50%;
-  transform: translateX(-50%);
-  width: 32px;
-  height: 40px;
-  background-color: #555;
-  border-radius: 4px;
-}
+/* Parallax container and layers stack behind the game and scroll horizontally. */
+#parallaxContainer {
+  position: absolute;
+  top: 0;
+  left: 0;
+  width: 100%;
+  height: 100%;
+  overflow: hidden;
+  z-index: 0;
+  pointer-events: none;
+}
+.parallax-layer {
+  position: absolute;
+  top: 0;
+  left: 0;
+  width: 100%;
+  height: 100%;
+  background-repeat: repeat-x;
+  background-position: 0 0;
+  background-size: cover;
+  pointer-events: none;
+}
+/* Canvas used to draw the animated climber sprite. It sits above the holds but below the UI. */
+#climberCanvas {
+  position: absolute;
+  bottom: 70px;
+  left: 50%;
+  transform: translateX(-50%);
+  width: 80px;
+  height: 200px;
+  z-index: 2;
+  pointer-events: none;
+}
*** End Patch
